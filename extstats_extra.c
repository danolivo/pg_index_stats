/*-------------------------------------------------------------------------
 *
 * extstats_extra.c
 *		Extra code to operate with extended statistics. Should correspond to any
 *		changes in extended_stats.c

 * Copyright (c) 2023 Andrei Lepikhov
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file for details.
 *
 * IDENTIFICATION
 *	  contrib/pg_sindex_stats/extstats_extra.c
 *
 *-------------------------------------------------------------------------
 */

#include "pg_index_stats.h"

#include "access/genam.h"
#include "access/htup_details.h"
#include "access/table.h"
#include "catalog/pg_statistic_ext.h"
#include "catalog/pg_type.h"
#include "commands/comment.h"
#include "nodes/nodeFuncs.h"
#include "optimizer/optimizer.h"
#include "utils/array.h"
#include "utils/builtins.h"
#include "utils/fmgroids.h"
#include "utils/lsyscache.h"
#include "utils/rel.h"
#include "utils/syscache.h"

typedef struct StatExtEntry
{
	Oid			statOid;		/* OID of pg_statistic_ext entry */
	char	   *schema;			/* statistics object's schema */
	char	   *name;			/* statistics object's name */
	Bitmapset  *columns;		/* attribute numbers covered by the object */
	List	   *types;			/* 'char' list of enabled statistics kinds */
	List	   *exprs;			/* expressions */
} StatExtEntry;

/* Comparison result of existed and candidate statistics */
#define CMPTYPE_DEFMATCH	(1) /* Equal definitions (need to check stat types) */
#define CMPTYPE_INCLUDES	(2) /* Definition of the stored covers incoming one */
#define CMPTYPE_INCLUDED	(3) /* Definition of the stored is covered by definition of incoming one */
#define CMPTYPE_INTERCEPT	(4) /* Both definitions have some unique elements */
#define CMPTYPE_NONE		(5) /* Nothing in common */

#define STAT_MCV			(0x01)
#define STAT_DEP			(0x02)
#define STAT_NDISTINCT		(0x04)

typedef struct StatAnalyzeResult
{
	int8			cmptype;
	bool			auto_generated; /* Generated by this extension? */

	Bitmapset	   *columns_matched;
	Bitmapset	   *columns_missed;
	Bitmapset	   *columns_extra;

	List		   *exprs_matched;
	List		   *exprs_missed;
	List		   *exprs_extra;

	Bitmapset	   *stat_matched;
	Bitmapset	   *stat_missed;

	StatExtEntry   *ref;
} StatAnalyzeResult;

/*
 * Extract auto-generated statistics
 */
static List *
fetch_statentries_for_relation(Relation pg_statext, Oid relid)
{
	SysScanDesc scan;
	ScanKeyData skey;
	HeapTuple	htup;
	List	   *result = NIL;

	/*
	 * Prepare to scan pg_statistic_ext for entries having stxrelid = this
	 * rel.
	 */
	ScanKeyInit(&skey,
				Anum_pg_statistic_ext_stxrelid,
				BTEqualStrategyNumber, F_OIDEQ,
				ObjectIdGetDatum(relid));

	scan = systable_beginscan(pg_statext, StatisticExtRelidIndexId, true,
							  NULL, 1, &skey);

	while (HeapTupleIsValid(htup = systable_getnext(scan)))
	{
		StatExtEntry *entry;
		Datum		datum;
		bool		isnull;
		int			i;
		ArrayType  *arr;
		char	   *enabled;
		Form_pg_statistic_ext staForm;
		List	   *exprs = NIL;

		entry = palloc0(sizeof(StatExtEntry));
		staForm = (Form_pg_statistic_ext) GETSTRUCT(htup);
		entry->statOid = staForm->oid;

		entry->schema = get_namespace_name(staForm->stxnamespace);
		entry->name = pstrdup(NameStr(staForm->stxname));
		for (i = 0; i < staForm->stxkeys.dim1; i++)
		{
			entry->columns = bms_add_member(entry->columns,
											staForm->stxkeys.values[i]);
		}

		/* decode the stxkind char array into a list of chars */
		datum = SysCacheGetAttrNotNull(STATEXTOID, htup,
									   Anum_pg_statistic_ext_stxkind);
		arr = DatumGetArrayTypeP(datum);
		if (ARR_NDIM(arr) != 1 ||
			ARR_HASNULL(arr) ||
			ARR_ELEMTYPE(arr) != CHAROID)
			elog(ERROR, "stxkind is not a 1-D char array");
		enabled = (char *) ARR_DATA_PTR(arr);
		for (i = 0; i < ARR_DIMS(arr)[0]; i++)
		{
			Assert((enabled[i] == STATS_EXT_NDISTINCT) ||
				   (enabled[i] == STATS_EXT_DEPENDENCIES) ||
				   (enabled[i] == STATS_EXT_MCV) ||
				   (enabled[i] == STATS_EXT_EXPRESSIONS));
			entry->types = lappend_int(entry->types, (int) enabled[i]);
		}

		/* decode expression (if any) */
		datum = SysCacheGetAttr(STATEXTOID, htup,
								Anum_pg_statistic_ext_stxexprs, &isnull);

		if (!isnull)
		{
			char	   *exprsString;

			exprsString = TextDatumGetCString(datum);
			exprs = (List *) stringToNode(exprsString);

			pfree(exprsString);

			/*
			 * Run the expressions through eval_const_expressions. This is not
			 * just an optimization, but is necessary, because the planner
			 * will be comparing them to similarly-processed qual clauses, and
			 * may fail to detect valid matches without this.  We must not use
			 * canonicalize_qual, however, since these aren't qual
			 * expressions.
			 */
			exprs = (List *) eval_const_expressions(NULL, (Node *) exprs);

			/* May as well fix opfuncids too */
			fix_opfuncids((Node *) exprs);
		}

		entry->exprs = exprs;

		result = lappend(result, entry);
	}

	systable_endscan(scan);

	return result;
}

/*
 * Pass through all extended statistics on the table.
 * Analyse intersection between candidate statistics and existed one.
 * Return list containing result of the analysis and links to specific entries.
 * Feel free to implement additional routines to make decisions on new
 * statistics and their fulfillment.
 */
List * /* of StatAnalyzeResult */
analyze_relation_statistics(Oid heapOid, Bitmapset *columns, List *exprs)
{
	Relation			pg_stext;
	List			   *statslist;
	ListCell		   *lc;
	StatAnalyzeResult  *result;
	List			   *resList = NIL;
	List			   *tmp_exprs;

	/* Extract all extended statistics on the relation */
	pg_stext = table_open(StatisticExtRelationId, AccessShareLock);
	statslist = fetch_statentries_for_relation(pg_stext, heapOid);
	table_close(pg_stext, AccessShareLock);

	/* Lookup for duplicated statistics */
	foreach(lc, statslist)
	{
		StatExtEntry   *entry = (StatExtEntry *) lfirst(lc);
		ListCell	   *lc1;
		char		   *stxcomment;

		/* Zeroing the struct on allocation to avoid annoying initializations */
		result = palloc0(sizeof(StatAnalyzeResult));

		/* Save link to statistics entry */
		result->ref = entry;

		/* Mark custom statistics has made by an user manually */
		stxcomment = GetComment(entry->statOid, StatisticExtRelationId, 0);
		if (stxcomment != NULL &&
			strstr(stxcomment, MODULE_NAME" - ") != NULL)
			result->auto_generated = true;

		/*
		 * Compare columns of already existed and candidate
		 * (induced by index creation) statistics
		 */
		result->columns_matched = bms_intersect(columns, entry->columns);
		result->columns_missed = bms_difference(columns, entry->columns);
		result->columns_extra = bms_difference(entry->columns, columns);
		Assert(bms_num_members(result->columns_matched) +
			bms_num_members(result->columns_missed) +
			bms_num_members(result->columns_extra) ==
			bms_num_members(bms_union(columns, entry->columns)));

		tmp_exprs = list_copy(entry->exprs);

		/*
		 * Do the same comparison for the expressions - a bit more heavy
		 * operation
		 */
		foreach (lc1, exprs)
		{
			StatsElem  *elem =  (StatsElem *) lfirst(lc1);
			Node	   *expr1 = elem->expr;
			Node	   *expr2 = NULL;
			ListCell   *lc2;
			bool		found = false;

			if (expr1 == NULL)
				/* It is a column, not an expression */
				continue;

			foreach (lc2, tmp_exprs)
			{
				expr2 = (Node *) lfirst(lc2);

				/* Don't wait NULL expression for stored statistics */
				Assert(expr2 != NULL);

				if (!equal(expr1, expr2))
					continue;

				/* We found match. Don't need to pass further. */
				found = true;
				break;
			}

			if (found)
			{
				Assert(expr2 != NULL);
				tmp_exprs = list_delete_ptr(tmp_exprs, expr2);
				result->exprs_matched = lappend(result->exprs_matched, expr1);
			}
			else
				/* Candidate column didn't find in the existed statistics */
				result->exprs_missed = lappend(result->exprs_missed, expr1);
		}

		/*
		 * Expressions, which weren't matched survive and should be stored as
		 * 'extra' expressions.
		 */
		result->exprs_extra = tmp_exprs;

		/* Now we can define relation between both statistics definitions */
		if (bms_is_empty(result->columns_matched) && result->exprs_matched == NIL)
			result->cmptype = CMPTYPE_NONE;
		/* Definitions have some common elements. Analyze further */
		else if ((result->exprs_missed != NULL || !bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra != NULL || !bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_INTERCEPT;
		else if ((result->exprs_missed != NULL || !bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra == NULL || bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_INCLUDED;
		else if ((result->exprs_missed == NULL || bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra != NULL || !bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_INCLUDES;
		else if ((result->exprs_missed == NULL && bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra == NULL && bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_DEFMATCH;
		else
			elog(PANIC, "Help! I've made a coding blunder!");
		resList = lappend(resList, result);

		/* Identify types of statistics in the entry */

		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_NDISTINCT);
		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_DEPENDENCIES);
		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_MCV);
		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_EXPRESSIONS);

		foreach(lc1, entry->types)
		{
			char		t = (char) lfirst_int(lc1);

			Assert(bms_is_member((int) t, result->stat_missed));

			if (t == STATS_EXT_EXPRESSIONS)
				/* TODO: elaborate logic by taking into account expression stats */
				continue;

			result->stat_matched = bms_add_member(result->stat_matched, (int) t);
		}
		result->stat_missed = bms_del_members(result->stat_missed, result->stat_matched);
		result->stat_missed = bms_del_member(result->stat_missed, (int) STATS_EXT_EXPRESSIONS);
	}

	list_free(statslist);
	return resList;
}

Bitmapset *
check_duplicated(List *statList)
{
	ListCell *lc;
	Bitmapset *missed = NULL;

	missed = bms_add_member(missed, (int) STATS_EXT_NDISTINCT);
	missed = bms_add_member(missed, (int) STATS_EXT_DEPENDENCIES);
	missed = bms_add_member(missed, (int) STATS_EXT_MCV);

	foreach (lc, statList)
	{
		StatAnalyzeResult *stat = (StatAnalyzeResult *) lfirst(lc);

		if (stat->cmptype == CMPTYPE_DEFMATCH)
			/*
			 * Stat stored contains the same definition. Exclude from the newly
			 * created statistics already existed fields.
			 */
			missed = bms_del_members(missed, stat->stat_matched);
	}

	return missed;
}
