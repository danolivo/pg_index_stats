/*-------------------------------------------------------------------------
 *
 * extstats_extra.c
 *		Extra code to operate with extended statistics. Should correspond to any
 *		changes in extended_stats.c

 * Copyright (c) 2023-2024 Andrei Lepikhov
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file for details.
 *
 * IDENTIFICATION
 *	  contrib/pg_sindex_stats/extstats_extra.c
 *
 *-------------------------------------------------------------------------
 */

#include "pg_index_stats.h"

#include "access/genam.h"
#include "access/table.h"
#include "catalog/pg_statistic_ext.h"
#include "commands/comment.h"
#include "statistics/statistics.h"
#include "utils/rel.h"

typedef struct StatExtEntry
{
	Oid			statOid;		/* OID of pg_statistic_ext entry */
	char	   *schema;			/* statistics object's schema */
	char	   *name;			/* statistics object's name */
	Bitmapset  *columns;		/* attribute numbers covered by the object */
	List	   *types;			/* 'char' list of enabled statistics kinds */
	int			stattarget;		/* statistics target (-1 for default) */
	List	   *exprs;			/* expressions */
} StatExtEntry;

/* Comparison result of existed and candidate statistics */
#define CMPTYPE_DEFMATCH	(1) /* Equal definitions (need to check stat types) */
#define CMPTYPE_INCLUDES	(2) /* Definition of the stored covers incoming one */
#define CMPTYPE_INCLUDED	(3) /* Definition of the stored is covered by definition of incoming one */
#define CMPTYPE_INTERCEPT	(4) /* Both definitions have some unique elements */
#define CMPTYPE_NONE		(5) /* Nothing in common */

#define STAT_MCV			(0x01)
#define STAT_DEP			(0x02)
#define STAT_NDISTINCT		(0x04)

typedef struct StatAnalyzeResult
{
	int8			cmptype;
	bool			auto_generated; /* Generated by this extension? */

	Bitmapset	   *columns_matched;
	Bitmapset	   *columns_missed;
	Bitmapset	   *columns_extra;

	List		   *exprs_matched;
	List		   *exprs_missed;
	List		   *exprs_extra;

	Bitmapset	   *stat_matched;
	Bitmapset	   *stat_missed;

	StatExtEntry   *ref;
} StatAnalyzeResult;

/*
 * Pass through all extended statistics on the table.
 * Analyse intersection between candidate statistics and existed one.
 * Return list containing result of the analysis and links to specific entries.
 * Feel free to implement additional routines to make decisions on new
 * statistics and their fulfillment.
 */
List * /* of StatAnalyzeResult */
analyze_relation_statistics(Oid heapOid, Bitmapset *columns, List *exprs)
{
	Relation			pg_stext;
	List			   *statslist;
	ListCell		   *lc;
	StatAnalyzeResult  *result;
	List			   *resList = NIL;
	List			   *tmp_exprs;

	/* Extract all extended statistics on the relation */
	pg_stext = table_open(StatisticExtRelationId, AccessShareLock);
	statslist = fetch_statentries_for_relation(pg_stext, heapOid);
	table_close(pg_stext, AccessShareLock);

	/* Lookup for duplicated statistics */
	foreach(lc, statslist)
	{
		StatExtEntry   *entry = (StatExtEntry *) lfirst(lc);
		ListCell	   *lc1;
		char		   *stxcomment;

		/* Zeroing the struct on allocation to avoid annoying initializations */
		result = palloc0(sizeof(StatAnalyzeResult));

		/* Save link to statistics entry */
		result->ref = entry;

		/* Mark custom statistics has made by an user manually */
		stxcomment = GetComment(entry->statOid, StatisticExtRelationId, 0);
		if (stxcomment != NULL &&
			strstr(stxcomment, EXTENSION_NAME" - ") != NULL)
			result->auto_generated = true;

		/*
		 * Compare columns of already existed and candidate
		 * (induced by index creation) statistics
		 */
		result->columns_matched = bms_intersect(columns, entry->columns);
		result->columns_missed = bms_difference(columns, entry->columns);
		result->columns_extra = bms_difference(entry->columns, columns);
		Assert(bms_num_members(result->columns_matched) +
			bms_num_members(result->columns_missed) +
			bms_num_members(result->columns_extra) ==
			bms_num_members(bms_union(columns, entry->columns)));

		tmp_exprs = list_copy(entry->exprs);

		/*
		 * Do the same comparison for the expressions - a bit more heavy
		 * operation
		 */
		foreach (lc1, exprs)
		{
			StatsElem  *elem =  (StatsElem *) lfirst(lc1);
			Node	   *expr1 = elem->expr;
			Node	   *expr2 = NULL;
			ListCell   *lc2;
			bool		found = false;

			if (expr1 == NULL)
				/* It is a column, not an expression */
				continue;

			foreach (lc2, tmp_exprs)
			{
				expr2 = (Node *) lfirst(lc2);

				/* Don't wait NULL expression for stored statistics */
				Assert(expr2 != NULL);

				if (!equal(expr1, expr2))
					continue;

				/* We found match. Don't need to pass further. */
				found = true;
				break;
			}

			if (found)
			{
				Assert(expr2 != NULL);
				tmp_exprs = list_delete_ptr(tmp_exprs, expr2);
				result->exprs_matched = lappend(result->exprs_matched, expr1);
			}
			else
				/* Candidate column didn't find in the existed statistics */
				result->exprs_missed = lappend(result->exprs_missed, expr1);
		}

		/*
		 * Expressions, which weren't matched survive and should be stored as
		 * 'extra' expressions.
		 */
		result->exprs_extra = tmp_exprs;

		/* Now we can define relation between both statistics definitions */
		if (bms_is_empty(result->columns_matched) && result->exprs_matched == NIL)
			result->cmptype = CMPTYPE_NONE;
		/* Definitions have some common elements. Analyze further */
		else if ((result->exprs_missed != NULL || !bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra != NULL || !bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_INTERCEPT;
		else if ((result->exprs_missed != NULL || !bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra == NULL || bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_INCLUDED;
		else if ((result->exprs_missed == NULL || bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra != NULL || !bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_INCLUDES;
		else if ((result->exprs_missed == NULL && bms_is_empty(result->columns_missed)) &&
				(result->exprs_extra == NULL && bms_is_empty(result->columns_extra)))
			result->cmptype = CMPTYPE_DEFMATCH;
		else
			elog(PANIC, "Help! I've made a coding blunder!");
		resList = lappend(resList, result);

		/* Identify types of statistics in the entry */

		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_NDISTINCT);
		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_DEPENDENCIES);
		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_MCV);
		result->stat_missed = bms_add_member(result->stat_missed, (int) STATS_EXT_EXPRESSIONS);

		foreach(lc1, entry->types)
		{
			char		t = (char) lfirst_int(lc1);

			Assert(bms_is_member((int) t, result->stat_missed));

			if (t == STATS_EXT_EXPRESSIONS)
				/* TODO: elaborate logic by taking into account expression stats */
				continue;

			result->stat_matched = bms_add_member(result->stat_matched, (int) t);
		}
		result->stat_missed = bms_del_members(result->stat_missed, result->stat_matched);
		result->stat_missed = bms_del_member(result->stat_missed, (int) STATS_EXT_EXPRESSIONS);
	}

	list_free(statslist);
	return resList;
}

Bitmapset *
check_duplicated(List *statList)
{
	ListCell *lc;
	Bitmapset *missed = NULL;

	missed = bms_add_member(missed, (int) STATS_EXT_NDISTINCT);
	missed = bms_add_member(missed, (int) STATS_EXT_DEPENDENCIES);
	missed = bms_add_member(missed, (int) STATS_EXT_MCV);

	foreach (lc, statList)
	{
		StatAnalyzeResult *stat = (StatAnalyzeResult *) lfirst(lc);

		if (stat->cmptype == CMPTYPE_DEFMATCH)
			/*
			 * Stat stored contains the same definition. Exclude from the newly
			 * created statistics already existed fields.
			 */
			missed = bms_del_members(missed, stat->stat_matched);
	}

	return missed;
}
